{
  "metadata": {
    "name": "design_patterns",
    "description": "Comprehensive design patterns for multiple languages",
    "total_patterns": 3,
    "categories": [
      "creational",
      "structural",
      "behavioral"
    ],
    "created_at": "2025-10-07T23:15:11.513967"
  },
  "patterns": [
    {
      "id": "pattern_singleton_001",
      "pattern_name": "Singleton Pattern",
      "category": "creational",
      "description": "Ensure a class has only one instance and provide global access",
      "use_case": "Database connections, logging, configuration managers",
      "implementations": {
        "python": "class DatabaseConnection:\n    _instance = None\n    _lock = threading.Lock()\n    \n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n                    cls._instance._initialize()\n        return cls._instance\n    \n    def _initialize(self):\n        self.connection = self._create_connection()\n    \n    def _create_connection(self):\n        return \"DB Connection\"\n    \n    @classmethod\n    def get_instance(cls):\n        return cls()",
        "javascript": "class DatabaseConnection {\n    static #instance = null;\n    \n    constructor() {\n        if (DatabaseConnection.#instance) {\n            return DatabaseConnection.#instance;\n        }\n        \n        this.connection = this.createConnection();\n        DatabaseConnection.#instance = this;\n    }\n    \n    createConnection() {\n        return 'DB Connection';\n    }\n    \n    static getInstance() {\n        if (!DatabaseConnection.#instance) {\n            DatabaseConnection.#instance = new DatabaseConnection();\n        }\n        return DatabaseConnection.#instance;\n    }\n}",
        "java": "public class DatabaseConnection {\n    private static volatile DatabaseConnection instance;\n    private String connection;\n    \n    private DatabaseConnection() {\n        this.connection = createConnection();\n    }\n    \n    public static DatabaseConnection getInstance() {\n        if (instance == null) {\n            synchronized (DatabaseConnection.class) {\n                if (instance == null) {\n                    instance = new DatabaseConnection();\n                }\n            }\n        }\n        return instance;\n    }\n    \n    private String createConnection() {\n        return \"DB Connection\";\n    }\n}"
      },
      "pros": [
        "Controlled access to sole instance",
        "Reduced namespace pollution",
        "Lazy initialization possible"
      ],
      "cons": [
        "Difficult to unit test",
        "Global state can cause issues",
        "Can hide dependencies"
      ]
    },
    {
      "id": "pattern_factory_001",
      "pattern_name": "Factory Pattern",
      "category": "creational",
      "description": "Create objects without specifying exact class",
      "use_case": "UI components, document parsers, database drivers",
      "implementations": {
        "python": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n\nclass AnimalFactory:\n    @staticmethod\n    def create_animal(animal_type):\n        if animal_type == \"dog\":\n            return Dog()\n        elif animal_type == \"cat\":\n            return Cat()\n        else:\n            raise ValueError(f\"Unknown animal type: {animal_type}\")\n\n# Usage\nfactory = AnimalFactory()\ndog = factory.create_animal(\"dog\")\nprint(dog.speak())  # Woof!",
        "javascript": "class Animal {\n    speak() {\n        throw new Error('Method must be implemented');\n    }\n}\n\nclass Dog extends Animal {\n    speak() {\n        return 'Woof!';\n    }\n}\n\nclass Cat extends Animal {\n    speak() {\n        return 'Meow!';\n    }\n}\n\nclass AnimalFactory {\n    static createAnimal(animalType) {\n        switch(animalType) {\n            case 'dog':\n                return new Dog();\n            case 'cat':\n                return new Cat();\n            default:\n                throw new Error(`Unknown animal type: ${animalType}`);\n        }\n    }\n}\n\n// Usage\nconst dog = AnimalFactory.createAnimal('dog');\nconsole.log(dog.speak()); // Woof!",
        "java": "interface Animal {\n    String speak();\n}\n\nclass Dog implements Animal {\n    public String speak() {\n        return \"Woof!\";\n    }\n}\n\nclass Cat implements Animal {\n    public String speak() {\n        return \"Meow!\";\n    }\n}\n\nclass AnimalFactory {\n    public static Animal createAnimal(String animalType) {\n        switch(animalType) {\n            case \"dog\":\n                return new Dog();\n            case \"cat\":\n                return new Cat();\n            default:\n                throw new IllegalArgumentException(\"Unknown animal type: \" + animalType);\n        }\n    }\n}\n\n// Usage\nAnimal dog = AnimalFactory.createAnimal(\"dog\");\nSystem.out.println(dog.speak()); // Woof!"
      },
      "pros": [
        "Loose coupling between creator and products",
        "Single responsibility principle",
        "Open/closed principle"
      ],
      "cons": [
        "Code can become more complex",
        "Need many subclasses"
      ]
    },
    {
      "id": "pattern_observer_001",
      "pattern_name": "Observer Pattern",
      "category": "behavioral",
      "description": "Define subscription mechanism to notify multiple objects",
      "use_case": "Event handling, UI updates, pub/sub systems",
      "implementations": {
        "python": "from typing import List, Protocol\n\nclass Observer(Protocol):\n    def update(self, message: str) -> None:\n        ...\n\nclass Subject:\n    def __init__(self):\n        self._observers: List[Observer] = []\n    \n    def attach(self, observer: Observer):\n        if observer not in self._observers:\n            self._observers.append(observer)\n    \n    def detach(self, observer: Observer):\n        self._observers.remove(observer)\n    \n    def notify(self, message: str):\n        for observer in self._observers:\n            observer.update(message)\n\nclass ConcreteObserver:\n    def __init__(self, name: str):\n        self.name = name\n    \n    def update(self, message: str):\n        print(f\"{self.name} received: {message}\")\n\n# Usage\nsubject = Subject()\nobserver1 = ConcreteObserver(\"Observer 1\")\nobserver2 = ConcreteObserver(\"Observer 2\")\n\nsubject.attach(observer1)\nsubject.attach(observer2)\nsubject.notify(\"Hello Observers!\")",
        "javascript": "class Subject {\n    constructor() {\n        this.observers = [];\n    }\n    \n    attach(observer) {\n        if (!this.observers.includes(observer)) {\n            this.observers.push(observer);\n        }\n    }\n    \n    detach(observer) {\n        const index = this.observers.indexOf(observer);\n        if (index > -1) {\n            this.observers.splice(index, 1);\n        }\n    }\n    \n    notify(message) {\n        this.observers.forEach(observer => observer.update(message));\n    }\n}\n\nclass ConcreteObserver {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    update(message) {\n        console.log(`${this.name} received: ${message}`);\n    }\n}\n\n// Usage\nconst subject = new Subject();\nconst observer1 = new ConcreteObserver('Observer 1');\nconst observer2 = new ConcreteObserver('Observer 2');\n\nsubject.attach(observer1);\nsubject.attach(observer2);\nsubject.notify('Hello Observers!');",
        "java": "import java.util.ArrayList;\nimport java.util.List;\n\ninterface Observer {\n    void update(String message);\n}\n\nclass Subject {\n    private List<Observer> observers = new ArrayList<>();\n    \n    public void attach(Observer observer) {\n        if (!observers.contains(observer)) {\n            observers.add(observer);\n        }\n    }\n    \n    public void detach(Observer observer) {\n        observers.remove(observer);\n    }\n    \n    public void notifyObservers(String message) {\n        for (Observer observer : observers) {\n            observer.update(message);\n        }\n    }\n}\n\nclass ConcreteObserver implements Observer {\n    private String name;\n    \n    public ConcreteObserver(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public void update(String message) {\n        System.out.println(name + \" received: \" + message);\n    }\n}\n\n// Usage\nSubject subject = new Subject();\nObserver observer1 = new ConcreteObserver(\"Observer 1\");\nObserver observer2 = new ConcreteObserver(\"Observer 2\");\n\nsubject.attach(observer1);\nsubject.attach(observer2);\nsubject.notifyObservers(\"Hello Observers!\");"
      },
      "pros": [
        "Loose coupling between subject and observers",
        "Open/closed principle",
        "Dynamic relationships at runtime"
      ],
      "cons": [
        "Observers notified in random order",
        "Memory leaks if not properly detached"
      ]
    }
  ]
}