{
  "metadata": {
    "source": "code_translation_examples",
    "type": "synthetic",
    "description": "Cross-language code translation examples",
    "languages": [
      "python",
      "javascript",
      "java",
      "cpp",
      "rust",
      "go"
    ],
    "total_examples": 3,
    "created_at": "2025-10-07T23:15:11.467860"
  },
  "translation_examples": [
    {
      "id": "trans_001",
      "concept": "fibonacci_sequence",
      "description": "Calculate Fibonacci sequence",
      "difficulty": "beginner",
      "implementations": {
        "python": "def fibonacci(n):\n    \"\"\"Calculate nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b",
        "javascript": "function fibonacci(n) {\n    // Calculate nth Fibonacci number\n    if (n <= 1) {\n        return n;\n    }\n    let [a, b] = [0, 1];\n    for (let i = 2; i <= n; i++) {\n        [a, b] = [b, a + b];\n    }\n    return b;\n}",
        "java": "public static int fibonacci(int n) {\n    // Calculate nth Fibonacci number\n    if (n <= 1) {\n        return n;\n    }\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; i++) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}",
        "cpp": "int fibonacci(int n) {\n    // Calculate nth Fibonacci number\n    if (n <= 1) {\n        return n;\n    }\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; i++) {\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}",
        "rust": "fn fibonacci(n: u32) -> u32 {\n    // Calculate nth Fibonacci number\n    if n <= 1 {\n        return n;\n    }\n    let (mut a, mut b) = (0, 1);\n    for _ in 2..=n {\n        let temp = a + b;\n        a = b;\n        b = temp;\n    }\n    b\n}",
        "go": "func fibonacci(n int) int {\n    // Calculate nth Fibonacci number\n    if n <= 1 {\n        return n\n    }\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}"
      },
      "key_differences": {
        "python": "Tuple unpacking for elegant swap",
        "javascript": "Array destructuring for swap",
        "java": "Explicit temporary variable needed",
        "cpp": "Similar to Java with C-style syntax",
        "rust": "Ownership system, immutable by default",
        "go": "Multiple return values for clean swap"
      }
    },
    {
      "id": "trans_002",
      "concept": "binary_search",
      "description": "Binary search in sorted array",
      "difficulty": "intermediate",
      "implementations": {
        "python": "def binary_search(arr, target):\n    \"\"\"Find target in sorted array using binary search.\"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1",
        "javascript": "function binarySearch(arr, target) {\n    // Find target in sorted array using binary search\n    let left = 0;\n    let right = arr.length - 1;\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        \n        if (arr[mid] === target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n}",
        "java": "public static int binarySearch(int[] arr, int target) {\n    // Find target in sorted array using binary search\n    int left = 0;\n    int right = arr.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n}",
        "cpp": "int binarySearch(const std::vector<int>& arr, int target) {\n    // Find target in sorted array using binary search\n    int left = 0;\n    int right = arr.size() - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n}",
        "rust": "fn binary_search(arr: &[i32], target: i32) -> Option<usize> {\n    // Find target in sorted array using binary search\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    \n    while left <= right {\n        let mid = left + (right - left) / 2;\n        \n        match arr[mid].cmp(&target) {\n            std::cmp::Ordering::Equal => return Some(mid),\n            std::cmp::Ordering::Less => left = mid + 1,\n            std::cmp::Ordering::Greater => {\n                if mid == 0 { break; }\n                right = mid - 1;\n            }\n        }\n    }\n    \n    None\n}",
        "go": "func binarySearch(arr []int, target int) int {\n    // Find target in sorted array using binary search\n    left, right := 0, len(arr)-1\n    \n    for left <= right {\n        mid := left + (right-left)/2\n        \n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    \n    return -1\n}"
      },
      "key_differences": {
        "python": "Simple integer division with //",
        "javascript": "Math.floor for integer division",
        "java": "Careful with integer overflow in mid calculation",
        "cpp": "Use const reference for input array",
        "rust": "Returns Option type, uses match for comparison",
        "go": "Multiple return values convention"
      }
    },
    {
      "id": "trans_003",
      "concept": "linked_list_reversal",
      "description": "Reverse a singly linked list",
      "difficulty": "intermediate",
      "implementations": {
        "python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_linked_list(head):\n    \"\"\"Reverse a singly linked list.\"\"\"\n    prev = None\n    current = head\n    \n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    \n    return prev",
        "javascript": "class ListNode {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction reverseLinkedList(head) {\n    // Reverse a singly linked list\n    let prev = null;\n    let current = head;\n    \n    while (current !== null) {\n        const nextNode = current.next;\n        current.next = prev;\n        prev = current;\n        current = nextNode;\n    }\n    \n    return prev;\n}",
        "java": "class ListNode {\n    int val;\n    ListNode next;\n    \n    ListNode(int val) {\n        this.val = val;\n        this.next = null;\n    }\n}\n\npublic static ListNode reverseLinkedList(ListNode head) {\n    // Reverse a singly linked list\n    ListNode prev = null;\n    ListNode current = head;\n    \n    while (current != null) {\n        ListNode nextNode = current.next;\n        current.next = prev;\n        prev = current;\n        current = nextNode;\n    }\n    \n    return prev;\n}",
        "cpp": "struct ListNode {\n    int val;\n    ListNode* next;\n    \n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* reverseLinkedList(ListNode* head) {\n    // Reverse a singly linked list\n    ListNode* prev = nullptr;\n    ListNode* current = head;\n    \n    while (current != nullptr) {\n        ListNode* nextNode = current->next;\n        current->next = prev;\n        prev = current;\n        current = nextNode;\n    }\n    \n    return prev;\n}",
        "rust": "#[derive(Debug)]\nstruct ListNode {\n    val: i32,\n    next: Option<Box<ListNode>>,\n}\n\nfn reverse_linked_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n    // Reverse a singly linked list\n    let mut prev = None;\n    let mut current = head;\n    \n    while let Some(mut node) = current {\n        let next = node.next.take();\n        node.next = prev;\n        prev = Some(node);\n        current = next;\n    }\n    \n    prev\n}",
        "go": "type ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc reverseLinkedList(head *ListNode) *ListNode {\n    // Reverse a singly linked list\n    var prev *ListNode\n    current := head\n    \n    for current != nil {\n        nextNode := current.Next\n        current.Next = prev\n        prev = current\n        current = nextNode\n    }\n    \n    return prev\n}"
      },
      "key_differences": {
        "python": "Simple pointer manipulation",
        "javascript": "Similar to Python with explicit null checks",
        "java": "Class-based with explicit constructors",
        "cpp": "Pointer manipulation with nullptr",
        "rust": "Ownership system requires take() for moving values",
        "go": "Pointer-based with nil checks"
      }
    }
  ]
}