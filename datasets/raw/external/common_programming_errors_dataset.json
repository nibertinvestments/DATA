{
  "metadata": {
    "source": "common_programming_errors",
    "type": "synthetic",
    "description": "Common programming errors and solutions",
    "languages": [
      "python",
      "javascript",
      "java",
      "cpp",
      "typescript"
    ],
    "total_patterns": 11,
    "created_at": "2025-10-07T23:08:43.179732"
  },
  "error_patterns": [
    {
      "id": "err_py_001",
      "language": "python",
      "error_type": "IndexError",
      "description": "List index out of range",
      "buggy_code": "def get_last_element(items):\n    return items[len(items)]  # Off-by-one error",
      "fixed_code": "def get_last_element(items):\n    if not items:\n        return None\n    return items[-1]  # Correct way to get last element",
      "explanation": "Python list indices start at 0, so the last element is at index len(items)-1, or simply items[-1]",
      "common_cause": "Off-by-one error, forgetting Python uses 0-based indexing",
      "severity": "medium",
      "category": "indexing"
    },
    {
      "id": "err_py_002",
      "language": "python",
      "error_type": "KeyError",
      "description": "Dictionary key not found",
      "buggy_code": "def get_user_email(users, user_id):\n    return users[user_id]['email']  # Crashes if user_id not in dict",
      "fixed_code": "def get_user_email(users, user_id):\n    user = users.get(user_id)\n    if user:\n        return user.get('email')\n    return None",
      "explanation": "Use .get() method to safely access dictionary keys without raising KeyError",
      "common_cause": "Not checking if key exists before accessing",
      "severity": "high",
      "category": "data_access"
    },
    {
      "id": "err_py_003",
      "language": "python",
      "error_type": "TypeError",
      "description": "String concatenation with non-string type",
      "buggy_code": "def create_message(name, age):\n    return \"User \" + name + \" is \" + age + \" years old\"  # age is int",
      "fixed_code": "def create_message(name, age):\n    return f\"User {name} is {age} years old\"  # f-string handles conversion",
      "explanation": "Use f-strings or str() to properly handle type conversion in string formatting",
      "common_cause": "Forgetting to convert non-string types in concatenation",
      "severity": "medium",
      "category": "type_handling"
    },
    {
      "id": "err_js_001",
      "language": "javascript",
      "error_type": "TypeError",
      "description": "Cannot read property of undefined",
      "buggy_code": "function getUserEmail(users, userId) {\n    return users[userId].email;  // Crashes if users[userId] is undefined\n}",
      "fixed_code": "function getUserEmail(users, userId) {\n    return users[userId]?.email;  // Optional chaining\n}",
      "explanation": "Use optional chaining (?.) to safely access nested properties",
      "common_cause": "Not checking if object exists before accessing properties",
      "severity": "high",
      "category": "data_access"
    },
    {
      "id": "err_js_002",
      "language": "javascript",
      "error_type": "ReferenceError",
      "description": "Variable used before declaration",
      "buggy_code": "function processData() {\n    console.log(result);  // ReferenceError\n    let result = calculateResult();\n    return result;\n}",
      "fixed_code": "function processData() {\n    let result = calculateResult();\n    console.log(result);\n    return result;\n}",
      "explanation": "Declare and initialize variables before using them to avoid temporal dead zone",
      "common_cause": "Hoisting confusion with let/const declarations",
      "severity": "high",
      "category": "scope"
    },
    {
      "id": "err_js_003",
      "language": "javascript",
      "error_type": "TypeError",
      "description": "Array method on non-array",
      "buggy_code": "function processItems(items) {\n    return items.map(item => item * 2);  // Fails if items is not array\n}",
      "fixed_code": "function processItems(items) {\n    if (!Array.isArray(items)) {\n        return [];\n    }\n    return items.map(item => item * 2);\n}",
      "explanation": "Always validate that input is an array before using array methods",
      "common_cause": "Assuming parameter type without validation",
      "severity": "medium",
      "category": "type_checking"
    },
    {
      "id": "err_java_001",
      "language": "java",
      "error_type": "NullPointerException",
      "description": "Calling method on null object",
      "buggy_code": "public String getUserEmail(User user) {\n    return user.getEmail();  // Throws NPE if user is null\n}",
      "fixed_code": "public String getUserEmail(User user) {\n    if (user == null) {\n        return null;\n    }\n    return user.getEmail();\n}",
      "explanation": "Always check for null before accessing object methods or properties",
      "common_cause": "Not validating object is non-null",
      "severity": "high",
      "category": "null_handling"
    },
    {
      "id": "err_java_002",
      "language": "java",
      "error_type": "ArrayIndexOutOfBoundsException",
      "description": "Array index exceeds bounds",
      "buggy_code": "public int getLastElement(int[] array) {\n    return array[array.length];  // Off-by-one error\n}",
      "fixed_code": "public int getLastElement(int[] array) {\n    if (array == null || array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    return array[array.length - 1];\n}",
      "explanation": "Array indices range from 0 to length-1, always validate bounds",
      "common_cause": "Off-by-one error in array indexing",
      "severity": "high",
      "category": "indexing"
    },
    {
      "id": "err_cpp_001",
      "language": "cpp",
      "error_type": "SegmentationFault",
      "description": "Dereferencing null pointer",
      "buggy_code": "int getValue(int* ptr) {\n    return *ptr;  // Crashes if ptr is nullptr\n}",
      "fixed_code": "int getValue(int* ptr) {\n    if (ptr == nullptr) {\n        throw std::invalid_argument(\"Pointer is null\");\n    }\n    return *ptr;\n}",
      "explanation": "Always check pointer is not nullptr before dereferencing",
      "common_cause": "Not validating pointer before use",
      "severity": "critical",
      "category": "pointer_safety"
    },
    {
      "id": "err_cpp_002",
      "language": "cpp",
      "error_type": "MemoryLeak",
      "description": "Memory not freed",
      "buggy_code": "void processData() {\n    int* data = new int[100];\n    // Process data\n    // Missing: delete[] data;\n}",
      "fixed_code": "void processData() {\n    std::vector<int> data(100);\n    // Process data\n    // Automatic cleanup\n}",
      "explanation": "Use RAII containers like std::vector to avoid manual memory management",
      "common_cause": "Forgetting to free dynamically allocated memory",
      "severity": "high",
      "category": "memory_management"
    },
    {
      "id": "err_ts_001",
      "language": "typescript",
      "error_type": "TypeError",
      "description": "Type assertion without validation",
      "buggy_code": "function processUser(data: unknown) {\n    const user = data as User;  // Unsafe cast\n    return user.email;\n}",
      "fixed_code": "function processUser(data: unknown): string | undefined {\n    if (typeof data === 'object' && data !== null && 'email' in data) {\n        return (data as User).email;\n    }\n    return undefined;\n}",
      "explanation": "Validate data structure before type assertions",
      "common_cause": "Unsafe type casting without runtime validation",
      "severity": "high",
      "category": "type_safety"
    }
  ]
}